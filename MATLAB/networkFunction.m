function [Y] = networkFunction(net,Xi,~)

%this has been modified from a funciton generated by genFunction, this
%should be compatible with networks of any size, and will simply evaluate
%once with the given delay states. 
% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = net.inputs{1}.processSettings{1}.xoffset;
x1_step1.gain=net.inputs{1}.processSettings{1}.gain;
x1_step1.ymin=net.inputs{1}.processSettings{1}.ymin;

IW1_1=net.IW{1};
% Output 1
y1_step1.ymin=net.outputs{net.numLayers}.processSettings{1}.ymin;
y1_step1.gain=net.outputs{net.numLayers}.processSettings{1}.gain;
y1_step1.xoffset=net.outputs{net.numLayers}.processSettings{1}.xoffset;

% ===== SIMULATION ========

%if (nargin < 2), error('Initial input states Xi argument needed.'); end


%Q = size(Xi{1},2);%width of inputs,ie number of categories%removed for
%simplification of repmat(), since it takes too long
%for ts=1:net.numInputDelays
    Xd1 = num2cell(mapminmax_apply(cell2mat(Xi),x1_step1));%simpler but not faster, approximately the same speed
    %Xd1{ts} = mapminmax_apply(Xi{1,ts},x1_step1);
%end

    
    % Rotating delay state position
    xdts = net.numInputDelays+1;
    
    % Input 1
    Xd1{xdts} = mapminmax_apply(1,x1_step1);
    
    % Layer 1
    tapdelay1 = cat(1,Xd1{mod(xdts-[1:net.numInputDelays]-1,net.numInputDelays+1)+1});
    
        a = tansig_apply(net.b{1} + IW1_1*tapdelay1);%first layer
    for n=1:net.numLayers-2%layers between first and last
        a = tansig_apply(net.b{n+1} + net.LW{n+1,n}*a);
    end
    a = net.b{end} + net.LW{end,end-1}*a;%last layer
    % Output 1
    Y = mapminmax_reverse(a,y1_step1);
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
